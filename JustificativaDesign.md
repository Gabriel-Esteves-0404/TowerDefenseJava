## Justificativa de Design – Checkpoints 1, 2 e 3

### Checkpoint 1 – Modelagem do mapa e caminho dos inimigos

No Checkpoint 1, o foco do design foi estruturar a base do tabuleiro e do movimento dos inimigos. Para isso, foi criada a classe `Posicao`, que encapsula linha e coluna de uma célula da grade, com métodos de acesso e sobrescrita de `equals`. A decisão de representar posições como um objeto próprio facilita comparações, manuseio de listas de posições e torna o código mais expressivo do que trabalhar apenas com pares de inteiros soltos.

A classe `Mapa` foi responsável por modelar a grade do jogo, utilizando um array bidimensional para representar as células. Cada célula pode ser marcada como construída ou não construível para torres, permitindo separar claramente a lógica de “onde posso construir” da lógica de movimento. Além disso, o mapa armazena o caminho pré-definido dos inimigos por meio de uma lista de `Posicao`, o que garante um movimento discreto, passo a passo, fácil de visualizar e de debugar. Essa escolha evita o acoplamento entre o movimento dos inimigos e detalhes de implementação da grade, e deixa o sistema preparado para futuros mapas com caminhos diferentes.

Por fim, a classe base de inimigos foi pensada para trabalhar em cima desse caminho, com um método de movimento que recebe o `Mapa` e atualiza a posição atual passo a passo. Assim, todo o raciocínio de “onde o inimigo está” e “qual a próxima célula” é guiado pelo caminho do mapa, centralizando o controle de layout no `Mapa` e mantendo os inimigos focados em comportamento.

---

### Checkpoint 2 – Torres, projéteis e sistema de combate

No Checkpoint 2, o objetivo de design foi construir um sistema de combate flexível e extensível, baseado em herança e polimorfismo. A classe abstrata `Torre` concentra o comportamento comum de todas as torres: dano base, intervalo de tiro, alcance, custo, cooldown e posição. Ela expõe métodos como `inimigosNoAlcance`, `proximoAlvo` e `atirar`, que definem o fluxo geral de ataque, enquanto detalhes específicos são delegados às subclasses. Essa abordagem permite adicionar novas torres sem modificar o código existente, respeitando o princípio de aberto/fechado.

Foram implementadas torres especializadas, como `TorreArqueira`, `TorrePoison` e `TorreFrozen`. Cada uma delas personaliza a forma de causar dano: a arqueira foca em dano direto, a torre de veneno aplica dano ao longo de vários ticks, e a torre congelante reduz ou interrompe o movimento do inimigo. Esse design reforça o uso de polimorfismo, pois o GameLoop não precisa saber qual torre está em uso; ele apenas chama métodos da classe base. Do lado dos inimigos, a hierarquia `Inimigos` + subclasses (`InimigosZumbi`, `InimigosCorredor`, `InimigosBlindado`, `InimigosGolem`, `InimigosGolemitas`) encapsula diferentes combinações de vida, velocidade, dano e recompensa, permitindo variar o desafio de forma controlada.

A classe `Projetil` foi criada para separar a lógica de disparo da lógica de dano. Um projétil conhece sua posição, seu alvo e a forma de se mover, e ao colidir chama `receberDano` e, quando necessário, aplica efeitos de status por meio de métodos como `aplicarEfeitosNoAlvo`. Essa separação deixa o código mais modular: efeitos como veneno e congelamento são tratados pela lógica do inimigo (em `atualizarEfeitos`), enquanto o projétil se limita a representar o disparo em si. Assim, o sistema de combate fica organizado em camadas e se torna mais fácil de manter e expandir.

---

### Checkpoint 3 – Economia, upgrades e laço de jogo completo

No Checkpoint 3, o design foi expandido para contemplar economia, upgrades e o laço de jogo completo (GameLoop), incluindo ondas de inimigos e condições de vitória/derrota. A camada de economia foi representada pelas classes `Banco` e `Loja`. O `Banco` centraliza o saldo do jogador, enquanto a `Loja` é responsável pela compra de torres, verificando se há saldo suficiente e debitando o valor. Exceções como `SaldoInsuficienteException` e `NivelMaximoException` tornam os erros de uso mais claros, reforçando regras de negócio importantes (como não permitir upgrades infinitos).

A classe `Torre` passou a incorporar atributos de nível (`nivel` e `maxNivel`) e o método `melhorar`, que consome recursos do banco e aplica upgrades específicos definidos nas subclasses. Isso reforça a tomada de decisão do jogador: investir em novas torres ou aprimorar as existentes. A mecânica de inimigos especiais, como o `InimigosGolem` que se divide em `InimigosGolemitas` ao morrer, foi integrada tanto na morte por projétil quanto na morte por veneno, aumentando a profundidade estratégica sem complicar o GameLoop.

O `GameLoop` e o `WaveManager` trabalham juntos para controlar a progressão da partida. O `WaveManager` define a composição das ondas, o intervalo de spawn e o número total de ondas, encapsulando toda a lógica de geração de inimigos em um único componente. Já o `GameLoop` coordena, a cada tick, a atualização dos inimigos (efeitos e movimento), a aplicação de dano na base, o disparo das torres, o avanço e colisão dos projéteis, a geração de novos inimigos (como golemitas) e, por fim, o spawn de novos inimigos da onda. A ordem dos eventos foi cuidadosamente escolhida para manter o jogo previsível e justo, com condições claras para GAME OVER (vida da base esgotada) e VITÓRIA (todas as ondas concluídas e sem inimigos ou projéteis ativos).

Dentro do conjunto de torres especializadas, a `TorrePoison` e a `TorreFrozen` foram pensadas para introduzir mecânicas de controle de área e dano ao longo do tempo, indo além do simples “dano imediato” da `TorreArqueira`. A `TorrePoison` aplica um efeito de veneno no inimigo através de projéteis específicos, armazenando internamente a duração desse efeito e o dano por tick. Esse veneno não remove a importância do dano direto, mas o complementa: inimigos com muita vida podem ser finalizados alguns ticks depois, mesmo que saiam temporariamente do foco das torres. O efeito é processado no método `atualizarEfeitos` da classe base de inimigos, o que mantém o GameLoop limpo e permite que qualquer inimigo possa ser envenenado sem precisar duplicar lógica em subclasses.

Já a `TorreFrozen` foi desenhada para atuar como ferramenta de controle de multidão (crowd control), aplicando congelamento ou redução de movimento em inimigos atingidos por seus projéteis. Em vez de “teletransportar” a responsabilidade para o GameLoop, o inimigo mantém um contador interno de ticks congelados, também atualizado em `atualizarEfeitos`. Enquanto estiver sob efeito, o inimigo deixa de se mover (ou tem seu avanço reduzido), o que dá tempo extra para as outras torres causarem dano. Esse design cria uma sinergia clara entre as torres: a Frozen ganha tempo, a Poison garante dano contínuo e a Arqueira finaliza alvos enfraquecidos. Além disso, manter os efeitos encapsulados na lógica dos inimigos torna simples adicionar novos tipos de torres de controle no futuro, reaproveitando o mesmo padrão de efeitos por tick.

Por fim, a classe `Main` atua apenas como ponto de configuração e entrada: instancia o mapa, o banco, o gerenciador de ondas, cria e posiciona as torres via `Loja`, aplica upgrades e inicia o loop de jogo. Isso mantém a responsabilidade de orquestração fora da lógica de domínio, deixando o projeto organizado em camadas bem definidas: modelo (mapa, inimigos, torres), economia, gerenciamento de ondas e laço principal do jogo. Esse conjunto de decisões de design resultou em um código modular, extensível e alinhado aos objetivos de cada checkpoint.

